-- @atlcompiler atl2006


-- Copies UML2 models

module UML2Copy;
create OUT: UML2 from IN: UML2;

helper def: inElements: Set(UML2!"ecore::EObject") =
	UML2!"ecore::EObject" -> allInstancesFrom('IN');

-- ======================================================================
-- UML2 copying rules begin
-- ======================================================================
-- Generated by: EModelCopyGenerator.atl 5428 2006-09-01 19:23:26Z dwagelaa
rule DurationInterval {
	from
		s: UML2!"uml::DurationInterval" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::DurationInterval" mapsTo s
}

rule Deployment {
	from
		s: UML2!"uml::Deployment" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Deployment" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			supplier <- s.supplier,
			client <- s.client,
			deployedArtifact <- s.deployedArtifact,
			configuration <- s.configuration
		)
}

rule Slot {
	from
		s: UML2!"uml::Slot" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Slot" mapsTo s (
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			definingFeature <- s.definingFeature,
			value <- s.value
		)
}

rule DataStoreNode {
	from
		s: UML2!"uml::DataStoreNode" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::DataStoreNode" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			ordering <- s.ordering,
			isControlType <- s.isControlType,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			type <- s.type,
			upperBound <- s.upperBound,
			inState <- s.inState,
			selection <- s.selection
		)
}

rule ReadIsClassifiedObjectAction {
	from
		s: UML2!"uml::ReadIsClassifiedObjectAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ReadIsClassifiedObjectAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isDirect <- s.isDirect,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			classifier <- s.classifier,
			result <- s.result,
			object <- s.object
		)
}

rule Substitution {
	from
		s: UML2!"uml::Substitution" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Substitution" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			supplier <- s.supplier,
			client <- s.client,
			mapping <- s.mapping,
			contract <- s.contract
		)
}

rule Model {
	from
		s: UML2!"uml::Model" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Model" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			viewpoint <- s.viewpoint,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			packageMerge <- s.packageMerge,
			packagedElement <- s.packagedElement,
			profileApplication <- s.profileApplication
		)
}

rule AddStructuralFeatureValueAction {
	from
		s: UML2!"uml::AddStructuralFeatureValueAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::AddStructuralFeatureValueAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isReplaceAll <- s.isReplaceAll,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			structuralFeature <- s.structuralFeature,
			object <- s.object,
			value <- s.value,
			insertAt <- s.insertAt
		)
}

rule QualifierValue {
	from
		s: UML2!"uml::QualifierValue" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::QualifierValue" mapsTo s (
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			qualifier <- s.qualifier,
			value <- s.value
		)
}

rule IntervalConstraint {
	from
		s: UML2!"uml::IntervalConstraint" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::IntervalConstraint")
		else
			false
		endif
		)
	to
		t: UML2!"uml::IntervalConstraint" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			constrainedElement <- s.constrainedElement,
			specification <- s.specification
		)
}

rule TimeObservation {
	from
		s: UML2!"uml::TimeObservation" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::TimeObservation" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			firstEvent <- s.firstEvent,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			event <- s.event
		)
}

rule InteractionUse {
	from
		s: UML2!"uml::InteractionUse" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::InteractionUse")
		else
			false
		endif
		)
	to
		t: UML2!"uml::InteractionUse" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			covered <- s.covered,
			generalOrdering <- s.generalOrdering,
			refersTo <- s.refersTo,
			actualGate <- s.actualGate,
			argument <- s.argument
		)
}

rule ValueSpecificationAction {
	from
		s: UML2!"uml::ValueSpecificationAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ValueSpecificationAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			value <- s.value,
			result <- s.result
		)
}

rule ClassifierTemplateParameter {
	from
		s: UML2!"uml::ClassifierTemplateParameter" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ClassifierTemplateParameter" mapsTo s (
			allowSubstitutable <- s.allowSubstitutable,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			parameteredElement <- s.parameteredElement,
			ownedParameteredElement <- s.ownedParameteredElement,
			default <- s.default,
			ownedDefault <- s.ownedDefault,
			defaultClassifier <- s.defaultClassifier,
			constrainingClassifier <- s.constrainingClassifier
		)
}

rule ReadLinkObjectEndQualifierAction {
	from
		s: UML2!"uml::ReadLinkObjectEndQualifierAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ReadLinkObjectEndQualifierAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			object <- s.object,
			result <- s.result,
			qualifier <- s.qualifier
		)
}

rule LiteralInteger {
	from
		s: UML2!"uml::LiteralInteger" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::LiteralInteger" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			value <- s.value,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			type <- s.type
		)
}

rule ForkNode {
	from
		s: UML2!"uml::ForkNode" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ForkNode" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode
		)
}

rule Port {
	from
		s: UML2!"uml::Port" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Port" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isStatic <- s.isStatic,
			isOrdered <- s.isOrdered,
			isUnique <- s.isUnique,
			isReadOnly <- s.isReadOnly,
			isDerived <- s.isDerived,
			isDerivedUnion <- s.isDerivedUnion,
			aggregation <- s.aggregation,
			isBehavior <- s.isBehavior,
			isService <- s.isService,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			type <- s.type,
			upperValue <- s.upperValue,
			lowerValue <- s.lowerValue,
			templateParameter <- s.templateParameter,
			end <- s.end,
			deployment <- s.deployment,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			redefinedProperty <- s.redefinedProperty,
			defaultValue <- s.defaultValue,
			subsettedProperty <- s.subsettedProperty,
			association <- s.association,
			qualifier <- s.qualifier,
			redefinedPort <- s.redefinedPort,
			protocol <- s.protocol
		)
}

rule CallBehaviorAction {
	from
		s: UML2!"uml::CallBehaviorAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::CallBehaviorAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isSynchronous <- s.isSynchronous,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			argument <- s.argument,
			onPort <- s.onPort,
			result <- s.result,
			behavior <- s.behavior
		)
}

rule ReadLinkObjectEndAction {
	from
		s: UML2!"uml::ReadLinkObjectEndAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ReadLinkObjectEndAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			object <- s.object,
			end <- s.end,
			result <- s.result
		)
}

rule StructuredActivityNode {
	from
		s: UML2!"uml::StructuredActivityNode" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::StructuredActivityNode")
		else
			false
		endif
		)
	to
		t: UML2!"uml::StructuredActivityNode" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			mustIsolate <- s.mustIsolate,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			variable <- s.variable,
			edge <- s.edge,
			node <- s.node
		)
}

rule Parameter {
	from
		s: UML2!"uml::Parameter" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Parameter" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isOrdered <- s.isOrdered,
			isUnique <- s.isUnique,
			direction <- s.direction,
			isException <- s.isException,
			isStream <- s.isStream,
			effect <- s.effect,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			type <- s.type,
			templateParameter <- s.templateParameter,
			end <- s.end,
			upperValue <- s.upperValue,
			lowerValue <- s.lowerValue,
			parameterSet <- s.parameterSet,
			defaultValue <- s.defaultValue
		)
}

rule InterfaceRealization {
	from
		s: UML2!"uml::InterfaceRealization" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::InterfaceRealization" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			supplier <- s.supplier,
			client <- s.client,
			mapping <- s.mapping,
			contract <- s.contract
		)
}

rule ConsiderIgnoreFragment {
	from
		s: UML2!"uml::ConsiderIgnoreFragment" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ConsiderIgnoreFragment" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			interactionOperator <- s.interactionOperator,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			covered <- s.covered,
			generalOrdering <- s.generalOrdering,
			operand <- s.operand,
			cfragmentGate <- s.cfragmentGate,
			message <- s.message
		)
}

rule UnmarshallAction {
	from
		s: UML2!"uml::UnmarshallAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::UnmarshallAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			result <- s.result,
			unmarshallType <- s.unmarshallType,
			object <- s.object
		)
}

rule StateInvariant {
	from
		s: UML2!"uml::StateInvariant" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::StateInvariant" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			covered <- s.covered,
			generalOrdering <- s.generalOrdering,
			invariant <- s.invariant
		)
}

rule OutputPin {
	from
		s: UML2!"uml::OutputPin" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::OutputPin" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			ordering <- s.ordering,
			isControlType <- s.isControlType,
			isOrdered <- s.isOrdered,
			isUnique <- s.isUnique,
			isControl <- s.isControl,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			type <- s.type,
			upperBound <- s.upperBound,
			inState <- s.inState,
			selection <- s.selection,
			upperValue <- s.upperValue,
			lowerValue <- s.lowerValue
		)
}

rule CombinedFragment {
	from
		s: UML2!"uml::CombinedFragment" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::CombinedFragment")
		else
			false
		endif
		)
	to
		t: UML2!"uml::CombinedFragment" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			interactionOperator <- s.interactionOperator,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			covered <- s.covered,
			generalOrdering <- s.generalOrdering,
			operand <- s.operand,
			cfragmentGate <- s.cfragmentGate
		)
}

rule FinalState {
	from
		s: UML2!"uml::FinalState" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::FinalState" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			submachine <- s.submachine,
			connection <- s.connection,
			connectionPoint <- s.connectionPoint,
			redefinedState <- s.redefinedState,
			stateInvariant <- s.stateInvariant,
			entry <- s.entry,
			exit <- s.exit,
			doActivity <- s.doActivity,
			deferrableTrigger <- s.deferrableTrigger,
			region <- s.region
		)
}

rule JoinNode {
	from
		s: UML2!"uml::JoinNode" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::JoinNode" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isCombineDuplicate <- s.isCombineDuplicate,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			joinSpec <- s.joinSpec
		)
}

rule DecisionNode {
	from
		s: UML2!"uml::DecisionNode" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::DecisionNode" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			decisionInput <- s.decisionInput
		)
}

rule OpaqueBehavior {
	from
		s: UML2!"uml::OpaqueBehavior" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::OpaqueBehavior")
		else
			false
		endif
		)
	to
		t: UML2!"uml::OpaqueBehavior" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			isActive <- s.isActive,
			isReentrant <- s.isReentrant,
			body <- s.body,
			language <- s.language,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			ownedAttribute <- s.ownedAttribute,
			ownedConnector <- s.ownedConnector,
			ownedBehavior <- s.ownedBehavior,
			classifierBehavior <- s.classifierBehavior,
			interfaceRealization <- s.interfaceRealization,
			ownedTrigger <- s.ownedTrigger,
			nestedClassifier <- s.nestedClassifier,
			ownedOperation <- s.ownedOperation,
			ownedReception <- s.ownedReception,
			redefinedBehavior <- s.redefinedBehavior,
			ownedParameter <- s.ownedParameter,
			precondition <- s.precondition,
			postcondition <- s.postcondition,
			ownedParameterSet <- s.ownedParameterSet,
			specification <- s.specification
		)
}

rule DataType {
	from
		s: UML2!"uml::DataType" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::DataType")
		else
			false
		endif
		)
	to
		t: UML2!"uml::DataType" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			ownedAttribute <- s.ownedAttribute,
			ownedOperation <- s.ownedOperation
		)
}

rule ClearAssociationAction {
	from
		s: UML2!"uml::ClearAssociationAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ClearAssociationAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			object <- s.object,
			association <- s.association
		)
}

rule LinkEndDestructionData {
	from
		s: UML2!"uml::LinkEndDestructionData" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::LinkEndDestructionData" mapsTo s (
			isDestroyDuplicates <- s.isDestroyDuplicates,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			value <- s.value,
			end <- s.end,
			qualifier <- s.qualifier,
			destroyAt <- s.destroyAt
		)
}

rule AddVariableValueAction {
	from
		s: UML2!"uml::AddVariableValueAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::AddVariableValueAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isReplaceAll <- s.isReplaceAll,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			variable <- s.variable,
			value <- s.value,
			insertAt <- s.insertAt
		)
}

rule Operation {
	from
		s: UML2!"uml::Operation" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Operation" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isStatic <- s.isStatic,
			isAbstract <- s.isAbstract,
			concurrency <- s.concurrency,
			isQuery <- s.isQuery,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			ownedParameter <- s.ownedParameter,
			method <- s.method,
			raisedException <- s.raisedException,
			ownedParameterSet <- s.ownedParameterSet,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			precondition <- s.precondition,
			postcondition <- s.postcondition,
			redefinedOperation <- s.redefinedOperation,
			bodyCondition <- s.bodyCondition
		)
}

rule LiteralString {
	from
		s: UML2!"uml::LiteralString" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::LiteralString" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			value <- s.value,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			type <- s.type
		)
}

rule ConditionalNode {
	from
		s: UML2!"uml::ConditionalNode" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ConditionalNode" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			mustIsolate <- s.mustIsolate,
			isDeterminate <- s.isDeterminate,
			isAssured <- s.isAssured,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			variable <- s.variable,
			edge <- s.edge,
			node <- s.node,
			clause <- s.clause,
			result <- s.result
		)
}

rule RedefinableTemplateSignature {
	from
		s: UML2!"uml::RedefinableTemplateSignature" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::RedefinableTemplateSignature" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			parameter <- s.parameter,
			ownedParameter <- s.ownedParameter,
			extendedSignature <- s.extendedSignature
		)
}

rule Class {
	from
		s: UML2!"uml::Class" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::Class")
		else
			false
		endif
		)
	to
		t: UML2!"uml::Class" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			isActive <- s.isActive,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			ownedAttribute <- s.ownedAttribute,
			ownedConnector <- s.ownedConnector,
			ownedBehavior <- s.ownedBehavior,
			classifierBehavior <- s.classifierBehavior,
			interfaceRealization <- s.interfaceRealization,
			ownedTrigger <- s.ownedTrigger,
			nestedClassifier <- s.nestedClassifier,
			ownedOperation <- s.ownedOperation,
			ownedReception <- s.ownedReception
		)
}

rule AcceptEventAction {
	from
		s: UML2!"uml::AcceptEventAction" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::AcceptEventAction")
		else
			false
		endif
		)
	to
		t: UML2!"uml::AcceptEventAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isUnmarshall <- s.isUnmarshall,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			result <- s.result,
			trigger <- s.trigger
		)
}

rule InstanceSpecification {
	from
		s: UML2!"uml::InstanceSpecification" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::InstanceSpecification")
		else
			false
		endif
		)
	to
		t: UML2!"uml::InstanceSpecification" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			deployment <- s.deployment,
			templateParameter <- s.templateParameter,
			classifier <- s.classifier,
			slot <- s.slot,
			specification <- s.specification
		)
}

rule Message {
	from
		s: UML2!"uml::Message" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Message" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			messageSort <- s.messageSort,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			receiveEvent <- s.receiveEvent,
			sendEvent <- s.sendEvent,
			connector <- s.connector,
			argument <- s.argument
		)
}

rule ClearVariableAction {
	from
		s: UML2!"uml::ClearVariableAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ClearVariableAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			variable <- s.variable
		)
}

rule Actor {
	from
		s: UML2!"uml::Actor" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Actor" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			ownedBehavior <- s.ownedBehavior,
			classifierBehavior <- s.classifierBehavior,
			interfaceRealization <- s.interfaceRealization,
			ownedTrigger <- s.ownedTrigger
		)
}

rule ActivityFinalNode {
	from
		s: UML2!"uml::ActivityFinalNode" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ActivityFinalNode" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode
		)
}

rule Trigger {
	from
		s: UML2!"uml::Trigger" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Trigger" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			event <- s.event,
			port <- s.port
		)
}

rule FlowFinalNode {
	from
		s: UML2!"uml::FlowFinalNode" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::FlowFinalNode" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode
		)
}

rule PackageImport {
	from
		s: UML2!"uml::PackageImport" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::PackageImport" mapsTo s (
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			importedPackage <- s.importedPackage
		)
}

rule Property {
	from
		s: UML2!"uml::Property" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::Property")
		else
			false
		endif
		)
	to
		t: UML2!"uml::Property" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isStatic <- s.isStatic,
			isOrdered <- s.isOrdered,
			isUnique <- s.isUnique,
			isReadOnly <- s.isReadOnly,
			isDerived <- s.isDerived,
			isDerivedUnion <- s.isDerivedUnion,
			aggregation <- s.aggregation,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			type <- s.type,
			upperValue <- s.upperValue,
			lowerValue <- s.lowerValue,
			templateParameter <- s.templateParameter,
			end <- s.end,
			deployment <- s.deployment,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			redefinedProperty <- s.redefinedProperty,
			defaultValue <- s.defaultValue,
			subsettedProperty <- s.subsettedProperty,
			association <- s.association,
			qualifier <- s.qualifier
		)
}

rule ExtensionEnd {
	from
		s: UML2!"uml::ExtensionEnd" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ExtensionEnd" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isStatic <- s.isStatic,
			isOrdered <- s.isOrdered,
			isUnique <- s.isUnique,
			isReadOnly <- s.isReadOnly,
			isDerived <- s.isDerived,
			isDerivedUnion <- s.isDerivedUnion,
			aggregation <- s.aggregation,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			type <- s.type,
			upperValue <- s.upperValue,
			lowerValue <- s.lowerValue,
			templateParameter <- s.templateParameter,
			end <- s.end,
			deployment <- s.deployment,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			redefinedProperty <- s.redefinedProperty,
			defaultValue <- s.defaultValue,
			subsettedProperty <- s.subsettedProperty,
			association <- s.association,
			qualifier <- s.qualifier
		)
}

rule PrimitiveType {
	from
		s: UML2!"uml::PrimitiveType" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::PrimitiveType" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			ownedAttribute <- s.ownedAttribute,
			ownedOperation <- s.ownedOperation
		)
}

rule EAnnotation {
	from
		s: UML2!"ecore::EAnnotation" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"ecore::EAnnotation" mapsTo s (
			source <- s.source,
			eAnnotations <- s.eAnnotations,
			details <- s.details,
			contents <- s.contents,
			references <- s.references
		)
}

rule ProtocolTransition {
	from
		s: UML2!"uml::ProtocolTransition" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ProtocolTransition" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			kind <- s.kind,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			target <- s.target,
			redefinedTransition <- s.redefinedTransition,
			guard <- s.guard,
			effect <- s.effect,
			trigger <- s.trigger,
			source <- s.source,
			postCondition <- s.postCondition,
			preCondition <- s.preCondition
		)
}

rule Node {
	from
		s: UML2!"uml::Node" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::Node")
		else
			false
		endif
		)
	to
		t: UML2!"uml::Node" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			isActive <- s.isActive,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			ownedAttribute <- s.ownedAttribute,
			ownedConnector <- s.ownedConnector,
			ownedBehavior <- s.ownedBehavior,
			classifierBehavior <- s.classifierBehavior,
			interfaceRealization <- s.interfaceRealization,
			ownedTrigger <- s.ownedTrigger,
			nestedClassifier <- s.nestedClassifier,
			ownedOperation <- s.ownedOperation,
			ownedReception <- s.ownedReception,
			deployment <- s.deployment,
			nestedNode <- s.nestedNode
		)
}

rule InformationFlow {
	from
		s: UML2!"uml::InformationFlow" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::InformationFlow" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			realization <- s.realization,
			conveyed <- s.conveyed,
			informationSource <- s.informationSource,
			informationTarget <- s.informationTarget,
			realizingActivityEdge <- s.realizingActivityEdge,
			realizingConnector <- s.realizingConnector,
			realizingMessage <- s.realizingMessage
		)
}

rule ProtocolStateMachine {
	from
		s: UML2!"uml::ProtocolStateMachine" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ProtocolStateMachine" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			isActive <- s.isActive,
			isReentrant <- s.isReentrant,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			ownedAttribute <- s.ownedAttribute,
			ownedConnector <- s.ownedConnector,
			ownedBehavior <- s.ownedBehavior,
			classifierBehavior <- s.classifierBehavior,
			interfaceRealization <- s.interfaceRealization,
			ownedTrigger <- s.ownedTrigger,
			nestedClassifier <- s.nestedClassifier,
			ownedOperation <- s.ownedOperation,
			ownedReception <- s.ownedReception,
			redefinedBehavior <- s.redefinedBehavior,
			ownedParameter <- s.ownedParameter,
			precondition <- s.precondition,
			postcondition <- s.postcondition,
			ownedParameterSet <- s.ownedParameterSet,
			specification <- s.specification,
			region <- s.region,
			submachineState <- s.submachineState,
			connectionPoint <- s.connectionPoint,
			extendedStateMachine <- s.extendedStateMachine,
			conformance <- s.conformance
		)
}

rule BehaviorExecutionSpecification {
	from
		s: UML2!"uml::BehaviorExecutionSpecification" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::BehaviorExecutionSpecification" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			covered <- s.covered,
			generalOrdering <- s.generalOrdering,
			start <- s.start,
			finish <- s.finish,
			behavior <- s.behavior
		)
}

rule Include {
	from
		s: UML2!"uml::Include" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Include" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			addition <- s.addition
		)
}

rule CallEvent {
	from
		s: UML2!"uml::CallEvent" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::CallEvent" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			operation <- s.operation
		)
}

rule AssociationClass {
	from
		s: UML2!"uml::AssociationClass" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::AssociationClass" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			isActive <- s.isActive,
			isDerived <- s.isDerived,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			ownedAttribute <- s.ownedAttribute,
			ownedConnector <- s.ownedConnector,
			ownedBehavior <- s.ownedBehavior,
			classifierBehavior <- s.classifierBehavior,
			interfaceRealization <- s.interfaceRealization,
			ownedTrigger <- s.ownedTrigger,
			nestedClassifier <- s.nestedClassifier,
			ownedOperation <- s.ownedOperation,
			ownedReception <- s.ownedReception,
			ownedEnd <- s.ownedEnd,
			memberEnd <- s.memberEnd,
			navigableOwnedEnd <- s.navigableOwnedEnd
		)
}

rule ElementImport {
	from
		s: UML2!"uml::ElementImport" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ElementImport" mapsTo s (
			visibility <- s.visibility,
			alias <- s.alias,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			importedElement <- s.importedElement
		)
}

rule CallOperationAction {
	from
		s: UML2!"uml::CallOperationAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::CallOperationAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isSynchronous <- s.isSynchronous,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			argument <- s.argument,
			onPort <- s.onPort,
			result <- s.result,
			operation <- s.operation,
			target <- s.target
		)
}

rule MergeNode {
	from
		s: UML2!"uml::MergeNode" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::MergeNode" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode
		)
}

rule ActionExecutionSpecification {
	from
		s: UML2!"uml::ActionExecutionSpecification" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ActionExecutionSpecification" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			covered <- s.covered,
			generalOrdering <- s.generalOrdering,
			start <- s.start,
			finish <- s.finish,
			action <- s.action
		)
}

rule Manifestation {
	from
		s: UML2!"uml::Manifestation" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Manifestation" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			supplier <- s.supplier,
			client <- s.client,
			mapping <- s.mapping,
			utilizedElement <- s.utilizedElement
		)
}

rule Pin {
	from
		s: UML2!"uml::Pin" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::Pin")
		else
			false
		endif
		)
	to
		t: UML2!"uml::Pin" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			ordering <- s.ordering,
			isControlType <- s.isControlType,
			isOrdered <- s.isOrdered,
			isUnique <- s.isUnique,
			isControl <- s.isControl,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			type <- s.type,
			upperBound <- s.upperBound,
			inState <- s.inState,
			selection <- s.selection,
			upperValue <- s.upperValue,
			lowerValue <- s.lowerValue
		)
}

rule CentralBufferNode {
	from
		s: UML2!"uml::CentralBufferNode" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::CentralBufferNode")
		else
			false
		endif
		)
	to
		t: UML2!"uml::CentralBufferNode" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			ordering <- s.ordering,
			isControlType <- s.isControlType,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			type <- s.type,
			upperBound <- s.upperBound,
			inState <- s.inState,
			selection <- s.selection
		)
}

rule EStringToStringMapEntry {
	from
		s: UML2!"ecore::EStringToStringMapEntry" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"ecore::EStringToStringMapEntry" mapsTo s (
			key <- s.key,
			value <- s.value
		)
}

rule DestructionEvent {
	from
		s: UML2!"uml::DestructionEvent" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::DestructionEvent" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter
		)
}

rule Package {
	from
		s: UML2!"uml::Package" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::Package")
		else
			false
		endif
		)
	to
		t: UML2!"uml::Package" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			packageMerge <- s.packageMerge,
			packagedElement <- s.packagedElement,
			profileApplication <- s.profileApplication
		)
}

rule ProtocolConformance {
	from
		s: UML2!"uml::ProtocolConformance" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ProtocolConformance" mapsTo s (
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			generalMachine <- s.generalMachine
		)
}

rule Signal {
	from
		s: UML2!"uml::Signal" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Signal" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			ownedAttribute <- s.ownedAttribute
		)
}

rule RaiseExceptionAction {
	from
		s: UML2!"uml::RaiseExceptionAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::RaiseExceptionAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			exception <- s.exception
		)
}

rule TimeExpression {
	from
		s: UML2!"uml::TimeExpression" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::TimeExpression" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			type <- s.type,
			expr <- s.expr,
			observation <- s.observation
		)
}

rule ConnectableElementTemplateParameter {
	from
		s: UML2!"uml::ConnectableElementTemplateParameter" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ConnectableElementTemplateParameter" mapsTo s (
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			parameteredElement <- s.parameteredElement,
			ownedParameteredElement <- s.ownedParameteredElement,
			default <- s.default,
			ownedDefault <- s.ownedDefault
		)
}

rule LoopNode {
	from
		s: UML2!"uml::LoopNode" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::LoopNode" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			mustIsolate <- s.mustIsolate,
			isTestedFirst <- s.isTestedFirst,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			variable <- s.variable,
			edge <- s.edge,
			node <- s.node,
			bodyPart <- s.bodyPart,
			setupPart <- s.setupPart,
			decider <- s.decider,
			test <- s.test,
			result <- s.result,
			loopVariable <- s.loopVariable,
			bodyOutput <- s.bodyOutput,
			loopVariableInput <- s.loopVariableInput
		)
}

rule TemplateParameter {
	from
		s: UML2!"uml::TemplateParameter" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::TemplateParameter")
		else
			false
		endif
		)
	to
		t: UML2!"uml::TemplateParameter" mapsTo s (
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			parameteredElement <- s.parameteredElement,
			ownedParameteredElement <- s.ownedParameteredElement,
			default <- s.default,
			ownedDefault <- s.ownedDefault
		)
}

rule RemoveVariableValueAction {
	from
		s: UML2!"uml::RemoveVariableValueAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::RemoveVariableValueAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isRemoveDuplicates <- s.isRemoveDuplicates,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			variable <- s.variable,
			value <- s.value,
			removeAt <- s.removeAt
		)
}

rule Usage {
	from
		s: UML2!"uml::Usage" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Usage" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			supplier <- s.supplier,
			client <- s.client
		)
}

rule Image {
	from
		s: UML2!"uml::Image" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Image" mapsTo s (
			content <- s.content,
			location <- s.location,
			format <- s.format,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment
		)
}

rule SendSignalEvent {
	from
		s: UML2!"uml::SendSignalEvent" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::SendSignalEvent" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			signal <- s.signal
		)
}

rule LinkEndData {
	from
		s: UML2!"uml::LinkEndData" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::LinkEndData")
		else
			false
		endif
		)
	to
		t: UML2!"uml::LinkEndData" mapsTo s (
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			value <- s.value,
			end <- s.end,
			qualifier <- s.qualifier
		)
}

rule LiteralUnlimitedNatural {
	from
		s: UML2!"uml::LiteralUnlimitedNatural" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::LiteralUnlimitedNatural" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			value <- s.value,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			type <- s.type
		)
}

rule ExpansionNode {
	from
		s: UML2!"uml::ExpansionNode" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ExpansionNode" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			ordering <- s.ordering,
			isControlType <- s.isControlType,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			type <- s.type,
			upperBound <- s.upperBound,
			inState <- s.inState,
			selection <- s.selection,
			regionAsOutput <- s.regionAsOutput,
			regionAsInput <- s.regionAsInput
		)
}

rule TemplateSignature {
	from
		s: UML2!"uml::TemplateSignature" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::TemplateSignature")
		else
			false
		endif
		)
	to
		t: UML2!"uml::TemplateSignature" mapsTo s (
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			parameter <- s.parameter,
			ownedParameter <- s.ownedParameter
		)
}

rule InputPin {
	from
		s: UML2!"uml::InputPin" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::InputPin")
		else
			false
		endif
		)
	to
		t: UML2!"uml::InputPin" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			ordering <- s.ordering,
			isControlType <- s.isControlType,
			isOrdered <- s.isOrdered,
			isUnique <- s.isUnique,
			isControl <- s.isControl,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			type <- s.type,
			upperBound <- s.upperBound,
			inState <- s.inState,
			selection <- s.selection,
			upperValue <- s.upperValue,
			lowerValue <- s.lowerValue
		)
}

rule Variable {
	from
		s: UML2!"uml::Variable" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Variable" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isOrdered <- s.isOrdered,
			isUnique <- s.isUnique,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			type <- s.type,
			templateParameter <- s.templateParameter,
			end <- s.end,
			upperValue <- s.upperValue,
			lowerValue <- s.lowerValue
		)
}

rule DestroyLinkAction {
	from
		s: UML2!"uml::DestroyLinkAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::DestroyLinkAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			endData <- s.endData,
			inputValue <- s.inputValue
		)
}

rule Duration {
	from
		s: UML2!"uml::Duration" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Duration" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			type <- s.type,
			expr <- s.expr,
			observation <- s.observation
		)
}

rule Comment {
	from
		s: UML2!"uml::Comment" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Comment" mapsTo s (
			body <- s.body,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			annotatedElement <- s.annotatedElement
		)
}

rule Continuation {
	from
		s: UML2!"uml::Continuation" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Continuation" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			setting <- s.setting,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			covered <- s.covered,
			generalOrdering <- s.generalOrdering
		)
}

rule Component {
	from
		s: UML2!"uml::Component" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Component" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			isActive <- s.isActive,
			isIndirectlyInstantiated <- s.isIndirectlyInstantiated,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			ownedAttribute <- s.ownedAttribute,
			ownedConnector <- s.ownedConnector,
			ownedBehavior <- s.ownedBehavior,
			classifierBehavior <- s.classifierBehavior,
			interfaceRealization <- s.interfaceRealization,
			ownedTrigger <- s.ownedTrigger,
			nestedClassifier <- s.nestedClassifier,
			ownedOperation <- s.ownedOperation,
			ownedReception <- s.ownedReception,
			packagedElement <- s.packagedElement,
			realization <- s.realization
		)
}

rule GeneralOrdering {
	from
		s: UML2!"uml::GeneralOrdering" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::GeneralOrdering" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			before <- s.before,
			after <- s.after
		)
}

rule OpaqueExpression {
	from
		s: UML2!"uml::OpaqueExpression" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::OpaqueExpression" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			body <- s.body,
			language <- s.language,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			type <- s.type,
			behavior <- s.behavior
		)
}

rule BroadcastSignalAction {
	from
		s: UML2!"uml::BroadcastSignalAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::BroadcastSignalAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			argument <- s.argument,
			onPort <- s.onPort,
			signal <- s.signal
		)
}

rule ExtensionPoint {
	from
		s: UML2!"uml::ExtensionPoint" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ExtensionPoint" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression
		)
}

rule CollaborationUse {
	from
		s: UML2!"uml::CollaborationUse" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::CollaborationUse" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			type <- s.type,
			roleBinding <- s.roleBinding
		)
}

rule ReplyAction {
	from
		s: UML2!"uml::ReplyAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ReplyAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			replyToCall <- s.replyToCall,
			returnInformation <- s.returnInformation,
			replyValue <- s.replyValue
		)
}

rule ChangeEvent {
	from
		s: UML2!"uml::ChangeEvent" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ChangeEvent" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			changeExpression <- s.changeExpression
		)
}

rule ActivityPartition {
	from
		s: UML2!"uml::ActivityPartition" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ActivityPartition" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isDimension <- s.isDimension,
			isExternal <- s.isExternal,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			node <- s.node,
			subpartition <- s.subpartition,
			represents <- s.represents,
			edge <- s.edge
		)
}

rule ExecutionOccurrenceSpecification {
	from
		s: UML2!"uml::ExecutionOccurrenceSpecification" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ExecutionOccurrenceSpecification" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			covered <- s.covered,
			generalOrdering <- s.generalOrdering,
			toBefore <- s.toBefore,
			event <- s.event,
			toAfter <- s.toAfter,
			execution <- s.execution
		)
}

rule OccurrenceSpecification {
	from
		s: UML2!"uml::OccurrenceSpecification" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::OccurrenceSpecification")
		else
			false
		endif
		)
	to
		t: UML2!"uml::OccurrenceSpecification" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			covered <- s.covered,
			generalOrdering <- s.generalOrdering,
			toBefore <- s.toBefore,
			event <- s.event,
			toAfter <- s.toAfter
		)
}

rule Realization {
	from
		s: UML2!"uml::Realization" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::Realization")
		else
			false
		endif
		)
	to
		t: UML2!"uml::Realization" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			supplier <- s.supplier,
			client <- s.client,
			mapping <- s.mapping
		)
}

rule SendObjectAction {
	from
		s: UML2!"uml::SendObjectAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::SendObjectAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			argument <- s.argument,
			onPort <- s.onPort,
			target <- s.target,
			request <- s.request
		)
}

rule Collaboration {
	from
		s: UML2!"uml::Collaboration" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Collaboration" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			ownedBehavior <- s.ownedBehavior,
			classifierBehavior <- s.classifierBehavior,
			interfaceRealization <- s.interfaceRealization,
			ownedTrigger <- s.ownedTrigger,
			ownedAttribute <- s.ownedAttribute,
			ownedConnector <- s.ownedConnector,
			collaborationRole <- s.collaborationRole
		)
}

rule Transition {
	from
		s: UML2!"uml::Transition" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::Transition")
		else
			false
		endif
		)
	to
		t: UML2!"uml::Transition" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			kind <- s.kind,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			target <- s.target,
			redefinedTransition <- s.redefinedTransition,
			guard <- s.guard,
			effect <- s.effect,
			trigger <- s.trigger,
			source <- s.source
		)
}

rule ControlFlow {
	from
		s: UML2!"uml::ControlFlow" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ControlFlow" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			source <- s.source,
			target <- s.target,
			redefinedEdge <- s.redefinedEdge,
			inPartition <- s.inPartition,
			guard <- s.guard,
			weight <- s.weight,
			interrupts <- s.interrupts
		)
}

rule TimeConstraint {
	from
		s: UML2!"uml::TimeConstraint" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::TimeConstraint" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			firstEvent <- s.firstEvent,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			constrainedElement <- s.constrainedElement,
			specification <- s.specification
		)
}

rule DurationConstraint {
	from
		s: UML2!"uml::DurationConstraint" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::DurationConstraint" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			firstEvent <- s.firstEvent,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			constrainedElement <- s.constrainedElement,
			specification <- s.specification
		)
}

rule TestIdentityAction {
	from
		s: UML2!"uml::TestIdentityAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::TestIdentityAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			first <- s.first,
			second <- s.second,
			result <- s.result
		)
}

rule ReduceAction {
	from
		s: UML2!"uml::ReduceAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ReduceAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isOrdered <- s.isOrdered,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			reducer <- s.reducer,
			result <- s.result,
			collection <- s.collection
		)
}

rule ConnectionPointReference {
	from
		s: UML2!"uml::ConnectionPointReference" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ConnectionPointReference" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			entry <- s.entry,
			exit <- s.exit
		)
}

rule GeneralizationSet {
	from
		s: UML2!"uml::GeneralizationSet" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::GeneralizationSet" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isCovering <- s.isCovering,
			isDisjoint <- s.isDisjoint,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			powertype <- s.powertype,
			generalization <- s.generalization
		)
}

rule TemplateParameterSubstitution {
	from
		s: UML2!"uml::TemplateParameterSubstitution" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::TemplateParameterSubstitution" mapsTo s (
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			formal <- s.formal,
			actual <- s.actual,
			ownedActual <- s.ownedActual
		)
}

rule StateMachine {
	from
		s: UML2!"uml::StateMachine" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::StateMachine")
		else
			false
		endif
		)
	to
		t: UML2!"uml::StateMachine" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			isActive <- s.isActive,
			isReentrant <- s.isReentrant,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			ownedAttribute <- s.ownedAttribute,
			ownedConnector <- s.ownedConnector,
			ownedBehavior <- s.ownedBehavior,
			classifierBehavior <- s.classifierBehavior,
			interfaceRealization <- s.interfaceRealization,
			ownedTrigger <- s.ownedTrigger,
			nestedClassifier <- s.nestedClassifier,
			ownedOperation <- s.ownedOperation,
			ownedReception <- s.ownedReception,
			redefinedBehavior <- s.redefinedBehavior,
			ownedParameter <- s.ownedParameter,
			precondition <- s.precondition,
			postcondition <- s.postcondition,
			ownedParameterSet <- s.ownedParameterSet,
			specification <- s.specification,
			region <- s.region,
			submachineState <- s.submachineState,
			connectionPoint <- s.connectionPoint,
			extendedStateMachine <- s.extendedStateMachine
		)
}

rule TimeInterval {
	from
		s: UML2!"uml::TimeInterval" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::TimeInterval" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			type <- s.type,
			min <- s.min,
			max <- s.max
		)
}

rule Lifeline {
	from
		s: UML2!"uml::Lifeline" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Lifeline" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			represents <- s.represents,
			selector <- s.selector,
			decomposedAs <- s.decomposedAs,
			coveredBy <- s.coveredBy
		)
}

rule SendSignalAction {
	from
		s: UML2!"uml::SendSignalAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::SendSignalAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			argument <- s.argument,
			onPort <- s.onPort,
			target <- s.target,
			signal <- s.signal
		)
}

rule SignalEvent {
	from
		s: UML2!"uml::SignalEvent" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::SignalEvent" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			signal <- s.signal
		)
}

rule EnumerationLiteral {
	from
		s: UML2!"uml::EnumerationLiteral" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::EnumerationLiteral" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			deployment <- s.deployment,
			templateParameter <- s.templateParameter,
			classifier <- s.classifier,
			slot <- s.slot,
			specification <- s.specification
		)
}

rule LiteralNull {
	from
		s: UML2!"uml::LiteralNull" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::LiteralNull" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			type <- s.type
		)
}

rule InformationItem {
	from
		s: UML2!"uml::InformationItem" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::InformationItem" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			represented <- s.represented
		)
}

rule AcceptCallAction {
	from
		s: UML2!"uml::AcceptCallAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::AcceptCallAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isUnmarshall <- s.isUnmarshall,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			result <- s.result,
			trigger <- s.trigger,
			returnInformation <- s.returnInformation
		)
}

rule CommunicationPath {
	from
		s: UML2!"uml::CommunicationPath" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::CommunicationPath" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			isDerived <- s.isDerived,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			ownedEnd <- s.ownedEnd,
			memberEnd <- s.memberEnd,
			navigableOwnedEnd <- s.navigableOwnedEnd
		)
}

rule StringExpression {
	from
		s: UML2!"uml::StringExpression" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::StringExpression" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			symbol <- s.symbol,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			type <- s.type,
			operand <- s.operand,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			subExpression <- s.subExpression
		)
}

rule InterruptibleActivityRegion {
	from
		s: UML2!"uml::InterruptibleActivityRegion" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::InterruptibleActivityRegion" mapsTo s (
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			node <- s.node,
			interruptingEdge <- s.interruptingEdge
		)
}

rule Interface {
	from
		s: UML2!"uml::Interface" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Interface" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			ownedAttribute <- s.ownedAttribute,
			ownedOperation <- s.ownedOperation,
			nestedClassifier <- s.nestedClassifier,
			redefinedInterface <- s.redefinedInterface,
			ownedReception <- s.ownedReception,
			protocol <- s.protocol
		)
}

rule ParameterSet {
	from
		s: UML2!"uml::ParameterSet" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ParameterSet" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			parameter <- s.parameter,
			condition <- s.condition
		)
}

rule ActionInputPin {
	from
		s: UML2!"uml::ActionInputPin" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ActionInputPin" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			ordering <- s.ordering,
			isControlType <- s.isControlType,
			isOrdered <- s.isOrdered,
			isUnique <- s.isUnique,
			isControl <- s.isControl,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			type <- s.type,
			upperBound <- s.upperBound,
			inState <- s.inState,
			selection <- s.selection,
			upperValue <- s.upperValue,
			lowerValue <- s.lowerValue,
			fromAction <- s.fromAction
		)
}

rule Association {
	from
		s: UML2!"uml::Association" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::Association")
		else
			false
		endif
		)
	to
		t: UML2!"uml::Association" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			isDerived <- s.isDerived,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			ownedEnd <- s.ownedEnd,
			memberEnd <- s.memberEnd,
			navigableOwnedEnd <- s.navigableOwnedEnd
		)
}

rule Constraint {
	from
		s: UML2!"uml::Constraint" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::Constraint")
		else
			false
		endif
		)
	to
		t: UML2!"uml::Constraint" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			constrainedElement <- s.constrainedElement,
			specification <- s.specification
		)
}

rule ReadVariableAction {
	from
		s: UML2!"uml::ReadVariableAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ReadVariableAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			variable <- s.variable,
			result <- s.result
		)
}

rule MessageOccurrenceSpecification {
	from
		s: UML2!"uml::MessageOccurrenceSpecification" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::MessageOccurrenceSpecification" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			covered <- s.covered,
			generalOrdering <- s.generalOrdering,
			toBefore <- s.toBefore,
			event <- s.event,
			toAfter <- s.toAfter,
			message <- s.message
		)
}

rule ExpansionRegion {
	from
		s: UML2!"uml::ExpansionRegion" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ExpansionRegion" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			mustIsolate <- s.mustIsolate,
			mode <- s.mode,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			variable <- s.variable,
			edge <- s.edge,
			node <- s.node,
			inputElement <- s.inputElement,
			outputElement <- s.outputElement
		)
}

rule CreateLinkObjectAction {
	from
		s: UML2!"uml::CreateLinkObjectAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::CreateLinkObjectAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			endData <- s.endData,
			inputValue <- s.inputValue,
			result <- s.result
		)
}

rule Activity {
	from
		s: UML2!"uml::Activity" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Activity" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			isActive <- s.isActive,
			isReentrant <- s.isReentrant,
			isReadOnly <- s.isReadOnly,
			isSingleExecution <- s.isSingleExecution,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			ownedAttribute <- s.ownedAttribute,
			ownedConnector <- s.ownedConnector,
			ownedBehavior <- s.ownedBehavior,
			classifierBehavior <- s.classifierBehavior,
			interfaceRealization <- s.interfaceRealization,
			ownedTrigger <- s.ownedTrigger,
			nestedClassifier <- s.nestedClassifier,
			ownedOperation <- s.ownedOperation,
			ownedReception <- s.ownedReception,
			redefinedBehavior <- s.redefinedBehavior,
			ownedParameter <- s.ownedParameter,
			precondition <- s.precondition,
			postcondition <- s.postcondition,
			ownedParameterSet <- s.ownedParameterSet,
			specification <- s.specification,
			variable <- s.variable,
			node <- s.node,
			edge <- s.edge,
			partition <- s.partition,
			group <- s.group
		)
}

rule Interval {
	from
		s: UML2!"uml::Interval" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::Interval")
		else
			false
		endif
		)
	to
		t: UML2!"uml::Interval" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			type <- s.type,
			min <- s.min,
			max <- s.max
		)
}

rule UseCase {
	from
		s: UML2!"uml::UseCase" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::UseCase" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			ownedBehavior <- s.ownedBehavior,
			classifierBehavior <- s.classifierBehavior,
			interfaceRealization <- s.interfaceRealization,
			ownedTrigger <- s.ownedTrigger,
			include <- s.include,
			extend <- s.extend,
			extensionPoint <- s.extensionPoint,
			subject <- s.subject
		)
}

rule Clause {
	from
		s: UML2!"uml::Clause" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Clause" mapsTo s (
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			test <- s.test,
			body <- s.body,
			predecessorClause <- s.predecessorClause,
			successorClause <- s.successorClause,
			decider <- s.decider,
			bodyOutput <- s.bodyOutput
		)
}

rule ReceiveOperationEvent {
	from
		s: UML2!"uml::ReceiveOperationEvent" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ReceiveOperationEvent" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			operation <- s.operation
		)
}

rule Connector {
	from
		s: UML2!"uml::Connector" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Connector" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isStatic <- s.isStatic,
			kind <- s.kind,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			type <- s.type,
			redefinedConnector <- s.redefinedConnector,
			end <- s.end,
			contract <- s.contract
		)
}

rule AnyReceiveEvent {
	from
		s: UML2!"uml::AnyReceiveEvent" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::AnyReceiveEvent" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter
		)
}

rule PartDecomposition {
	from
		s: UML2!"uml::PartDecomposition" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::PartDecomposition" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			covered <- s.covered,
			generalOrdering <- s.generalOrdering,
			refersTo <- s.refersTo,
			actualGate <- s.actualGate,
			argument <- s.argument
		)
}

rule Region {
	from
		s: UML2!"uml::Region" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Region" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			subvertex <- s.subvertex,
			transition <- s.transition,
			extendedRegion <- s.extendedRegion
		)
}

rule OpaqueAction {
	from
		s: UML2!"uml::OpaqueAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::OpaqueAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			body <- s.body,
			language <- s.language,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			inputValue <- s.inputValue,
			outputValue <- s.outputValue
		)
}

rule Pseudostate {
	from
		s: UML2!"uml::Pseudostate" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Pseudostate" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			kind <- s.kind,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming
		)
}

rule PackageMerge {
	from
		s: UML2!"uml::PackageMerge" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::PackageMerge" mapsTo s (
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			mergedPackage <- s.mergedPackage
		)
}

rule LiteralBoolean {
	from
		s: UML2!"uml::LiteralBoolean" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::LiteralBoolean" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			value <- s.value,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			type <- s.type
		)
}

rule SequenceNode {
	from
		s: UML2!"uml::SequenceNode" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::SequenceNode" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			mustIsolate <- s.mustIsolate,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			variable <- s.variable,
			edge <- s.edge,
			node <- s.node,
			executableNode <- s.executableNode
		)
}

rule DeploymentSpecification {
	from
		s: UML2!"uml::DeploymentSpecification" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::DeploymentSpecification" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			fileName <- s.fileName,
			deploymentLocation <- s.deploymentLocation,
			executionLocation <- s.executionLocation,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			nestedArtifact <- s.nestedArtifact,
			manifestation <- s.manifestation,
			ownedOperation <- s.ownedOperation,
			ownedAttribute <- s.ownedAttribute
		)
}

rule InteractionOperand {
	from
		s: UML2!"uml::InteractionOperand" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::InteractionOperand" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			covered <- s.covered,
			generalOrdering <- s.generalOrdering,
			guard <- s.guard,
			fragment <- s.fragment
		)
}

rule Extension {
	from
		s: UML2!"uml::Extension" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Extension" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			isDerived <- s.isDerived,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			ownedEnd <- s.ownedEnd,
			memberEnd <- s.memberEnd,
			navigableOwnedEnd <- s.navigableOwnedEnd
		)
}

rule SendOperationEvent {
	from
		s: UML2!"uml::SendOperationEvent" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::SendOperationEvent" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			operation <- s.operation
		)
}

rule ReceiveSignalEvent {
	from
		s: UML2!"uml::ReceiveSignalEvent" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ReceiveSignalEvent" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			signal <- s.signal
		)
}

rule Interaction {
	from
		s: UML2!"uml::Interaction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Interaction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			isActive <- s.isActive,
			isReentrant <- s.isReentrant,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			ownedAttribute <- s.ownedAttribute,
			ownedConnector <- s.ownedConnector,
			ownedBehavior <- s.ownedBehavior,
			classifierBehavior <- s.classifierBehavior,
			interfaceRealization <- s.interfaceRealization,
			ownedTrigger <- s.ownedTrigger,
			nestedClassifier <- s.nestedClassifier,
			ownedOperation <- s.ownedOperation,
			ownedReception <- s.ownedReception,
			redefinedBehavior <- s.redefinedBehavior,
			ownedParameter <- s.ownedParameter,
			precondition <- s.precondition,
			postcondition <- s.postcondition,
			ownedParameterSet <- s.ownedParameterSet,
			specification <- s.specification,
			covered <- s.covered,
			generalOrdering <- s.generalOrdering,
			lifeline <- s.lifeline,
			fragment <- s.fragment,
			action <- s.action,
			formalGate <- s.formalGate,
			message <- s.message
		)
}

rule ObjectFlow {
	from
		s: UML2!"uml::ObjectFlow" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ObjectFlow" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isMulticast <- s.isMulticast,
			isMultireceive <- s.isMultireceive,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			source <- s.source,
			target <- s.target,
			redefinedEdge <- s.redefinedEdge,
			inPartition <- s.inPartition,
			guard <- s.guard,
			weight <- s.weight,
			interrupts <- s.interrupts,
			transformation <- s.transformation,
			selection <- s.selection
		)
}

rule ReclassifyObjectAction {
	from
		s: UML2!"uml::ReclassifyObjectAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ReclassifyObjectAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isReplaceAll <- s.isReplaceAll,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			oldClassifier <- s.oldClassifier,
			newClassifier <- s.newClassifier,
			object <- s.object
		)
}

rule TemplateBinding {
	from
		s: UML2!"uml::TemplateBinding" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::TemplateBinding" mapsTo s (
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			signature <- s.signature,
			parameterSubstitution <- s.parameterSubstitution
		)
}

rule ValuePin {
	from
		s: UML2!"uml::ValuePin" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ValuePin" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			ordering <- s.ordering,
			isControlType <- s.isControlType,
			isOrdered <- s.isOrdered,
			isUnique <- s.isUnique,
			isControl <- s.isControl,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			type <- s.type,
			upperBound <- s.upperBound,
			inState <- s.inState,
			selection <- s.selection,
			upperValue <- s.upperValue,
			lowerValue <- s.lowerValue,
			value <- s.value
		)
}

rule RemoveStructuralFeatureValueAction {
	from
		s: UML2!"uml::RemoveStructuralFeatureValueAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::RemoveStructuralFeatureValueAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isRemoveDuplicates <- s.isRemoveDuplicates,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			structuralFeature <- s.structuralFeature,
			object <- s.object,
			value <- s.value,
			removeAt <- s.removeAt
		)
}

rule StartClassifierBehaviorAction {
	from
		s: UML2!"uml::StartClassifierBehaviorAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::StartClassifierBehaviorAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			object <- s.object
		)
}

rule ClearStructuralFeatureAction {
	from
		s: UML2!"uml::ClearStructuralFeatureAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ClearStructuralFeatureAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			structuralFeature <- s.structuralFeature,
			object <- s.object
		)
}

rule DurationObservation {
	from
		s: UML2!"uml::DurationObservation" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::DurationObservation" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			firstEvent <- s.firstEvent,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			event <- s.event
		)
}

rule CreationEvent {
	from
		s: UML2!"uml::CreationEvent" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::CreationEvent" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter
		)
}

rule State {
	from
		s: UML2!"uml::State" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::State")
		else
			false
		endif
		)
	to
		t: UML2!"uml::State" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			submachine <- s.submachine,
			connection <- s.connection,
			connectionPoint <- s.connectionPoint,
			redefinedState <- s.redefinedState,
			stateInvariant <- s.stateInvariant,
			entry <- s.entry,
			exit <- s.exit,
			doActivity <- s.doActivity,
			deferrableTrigger <- s.deferrableTrigger,
			region <- s.region
		)
}

rule Reception {
	from
		s: UML2!"uml::Reception" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Reception" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isStatic <- s.isStatic,
			isAbstract <- s.isAbstract,
			concurrency <- s.concurrency,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			ownedParameter <- s.ownedParameter,
			method <- s.method,
			raisedException <- s.raisedException,
			ownedParameterSet <- s.ownedParameterSet,
			signal <- s.signal
		)
}

rule ConnectorEnd {
	from
		s: UML2!"uml::ConnectorEnd" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ConnectorEnd" mapsTo s (
			isOrdered <- s.isOrdered,
			isUnique <- s.isUnique,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			upperValue <- s.upperValue,
			lowerValue <- s.lowerValue,
			partWithPort <- s.partWithPort,
			role <- s.role
		)
}

rule InteractionConstraint {
	from
		s: UML2!"uml::InteractionConstraint" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::InteractionConstraint" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			constrainedElement <- s.constrainedElement,
			specification <- s.specification,
			minint <- s.minint,
			maxint <- s.maxint
		)
}

rule ReadStructuralFeatureAction {
	from
		s: UML2!"uml::ReadStructuralFeatureAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ReadStructuralFeatureAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			structuralFeature <- s.structuralFeature,
			object <- s.object,
			result <- s.result
		)
}

rule ExceptionHandler {
	from
		s: UML2!"uml::ExceptionHandler" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ExceptionHandler" mapsTo s (
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			handlerBody <- s.handlerBody,
			exceptionInput <- s.exceptionInput,
			exceptionType <- s.exceptionType
		)
}

rule ReadExtentAction {
	from
		s: UML2!"uml::ReadExtentAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ReadExtentAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			result <- s.result,
			classifier <- s.classifier
		)
}

rule Gate {
	from
		s: UML2!"uml::Gate" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Gate" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			message <- s.message
		)
}

rule ExecutionEvent {
	from
		s: UML2!"uml::ExecutionEvent" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ExecutionEvent" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter
		)
}

rule ProfileApplication {
	from
		s: UML2!"uml::ProfileApplication" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ProfileApplication" mapsTo s (
			isStrict <- s.isStrict,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			appliedProfile <- s.appliedProfile
		)
}

rule Artifact {
	from
		s: UML2!"uml::Artifact" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::Artifact")
		else
			false
		endif
		)
	to
		t: UML2!"uml::Artifact" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			fileName <- s.fileName,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			nestedArtifact <- s.nestedArtifact,
			manifestation <- s.manifestation,
			ownedOperation <- s.ownedOperation,
			ownedAttribute <- s.ownedAttribute
		)
}

rule Generalization {
	from
		s: UML2!"uml::Generalization" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Generalization" mapsTo s (
			isSubstitutable <- s.isSubstitutable,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			general <- s.general,
			generalizationSet <- s.generalizationSet
		)
}

rule Device {
	from
		s: UML2!"uml::Device" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Device" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			isActive <- s.isActive,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			ownedAttribute <- s.ownedAttribute,
			ownedConnector <- s.ownedConnector,
			ownedBehavior <- s.ownedBehavior,
			classifierBehavior <- s.classifierBehavior,
			interfaceRealization <- s.interfaceRealization,
			ownedTrigger <- s.ownedTrigger,
			nestedClassifier <- s.nestedClassifier,
			ownedOperation <- s.ownedOperation,
			ownedReception <- s.ownedReception,
			deployment <- s.deployment,
			nestedNode <- s.nestedNode
		)
}

rule InitialNode {
	from
		s: UML2!"uml::InitialNode" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::InitialNode" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode
		)
}

rule ExecutionEnvironment {
	from
		s: UML2!"uml::ExecutionEnvironment" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ExecutionEnvironment" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			isActive <- s.isActive,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			ownedAttribute <- s.ownedAttribute,
			ownedConnector <- s.ownedConnector,
			ownedBehavior <- s.ownedBehavior,
			classifierBehavior <- s.classifierBehavior,
			interfaceRealization <- s.interfaceRealization,
			ownedTrigger <- s.ownedTrigger,
			nestedClassifier <- s.nestedClassifier,
			ownedOperation <- s.ownedOperation,
			ownedReception <- s.ownedReception,
			deployment <- s.deployment,
			nestedNode <- s.nestedNode
		)
}

rule TimeEvent {
	from
		s: UML2!"uml::TimeEvent" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::TimeEvent" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isRelative <- s.isRelative,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			when <- s.when
		)
}

rule OperationTemplateParameter {
	from
		s: UML2!"uml::OperationTemplateParameter" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::OperationTemplateParameter" mapsTo s (
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			parameteredElement <- s.parameteredElement,
			ownedParameteredElement <- s.ownedParameteredElement,
			default <- s.default,
			ownedDefault <- s.ownedDefault
		)
}

rule CreateObjectAction {
	from
		s: UML2!"uml::CreateObjectAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::CreateObjectAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			classifier <- s.classifier,
			result <- s.result
		)
}

rule FunctionBehavior {
	from
		s: UML2!"uml::FunctionBehavior" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::FunctionBehavior" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			isActive <- s.isActive,
			isReentrant <- s.isReentrant,
			body <- s.body,
			language <- s.language,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			ownedAttribute <- s.ownedAttribute,
			ownedConnector <- s.ownedConnector,
			ownedBehavior <- s.ownedBehavior,
			classifierBehavior <- s.classifierBehavior,
			interfaceRealization <- s.interfaceRealization,
			ownedTrigger <- s.ownedTrigger,
			nestedClassifier <- s.nestedClassifier,
			ownedOperation <- s.ownedOperation,
			ownedReception <- s.ownedReception,
			redefinedBehavior <- s.redefinedBehavior,
			ownedParameter <- s.ownedParameter,
			precondition <- s.precondition,
			postcondition <- s.postcondition,
			ownedParameterSet <- s.ownedParameterSet,
			specification <- s.specification
		)
}

rule CreateLinkAction {
	from
		s: UML2!"uml::CreateLinkAction" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::CreateLinkAction")
		else
			false
		endif
		)
	to
		t: UML2!"uml::CreateLinkAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			endData <- s.endData,
			inputValue <- s.inputValue
		)
}

rule LinkEndCreationData {
	from
		s: UML2!"uml::LinkEndCreationData" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::LinkEndCreationData" mapsTo s (
			isReplaceAll <- s.isReplaceAll,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			value <- s.value,
			end <- s.end,
			qualifier <- s.qualifier,
			insertAt <- s.insertAt
		)
}

rule ReadSelfAction {
	from
		s: UML2!"uml::ReadSelfAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ReadSelfAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			result <- s.result
		)
}

rule Expression {
	from
		s: UML2!"uml::Expression" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::Expression")
		else
			false
		endif
		)
	to
		t: UML2!"uml::Expression" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			symbol <- s.symbol,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			type <- s.type,
			operand <- s.operand
		)
}

rule Dependency {
	from
		s: UML2!"uml::Dependency" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::Dependency")
		else
			false
		endif
		)
	to
		t: UML2!"uml::Dependency" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			supplier <- s.supplier,
			client <- s.client
		)
}

rule Abstraction {
	from
		s: UML2!"uml::Abstraction" (
			if thisModule.inElements -> includes(s) then
			s -> oclIsTypeOf(UML2!"uml::Abstraction")
		else
			false
		endif
		)
	to
		t: UML2!"uml::Abstraction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			supplier <- s.supplier,
			client <- s.client,
			mapping <- s.mapping
		)
}

rule InstanceValue {
	from
		s: UML2!"uml::InstanceValue" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::InstanceValue" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			type <- s.type,
			instance <- s.instance
		)
}

rule DestroyObjectAction {
	from
		s: UML2!"uml::DestroyObjectAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::DestroyObjectAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isDestroyLinks <- s.isDestroyLinks,
			isDestroyOwnedObjects <- s.isDestroyOwnedObjects,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			target <- s.target
		)
}

rule ReadLinkAction {
	from
		s: UML2!"uml::ReadLinkAction" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ReadLinkAction" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			handler <- s.handler,
			localPrecondition <- s.localPrecondition,
			localPostcondition <- s.localPostcondition,
			endData <- s.endData,
			inputValue <- s.inputValue,
			result <- s.result
		)
}

rule Extend {
	from
		s: UML2!"uml::Extend" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Extend" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			extendedCase <- s.extendedCase,
			condition <- s.condition,
			extensionLocation <- s.extensionLocation
		)
}

rule ActivityParameterNode {
	from
		s: UML2!"uml::ActivityParameterNode" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ActivityParameterNode" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			ordering <- s.ordering,
			isControlType <- s.isControlType,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			outgoing <- s.outgoing,
			incoming <- s.incoming,
			inPartition <- s.inPartition,
			inInterruptibleRegion <- s.inInterruptibleRegion,
			redefinedNode <- s.redefinedNode,
			type <- s.type,
			upperBound <- s.upperBound,
			inState <- s.inState,
			selection <- s.selection,
			parameter <- s.parameter
		)
}

rule ComponentRealization {
	from
		s: UML2!"uml::ComponentRealization" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::ComponentRealization" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			templateParameter <- s.templateParameter,
			supplier <- s.supplier,
			client <- s.client,
			mapping <- s.mapping,
			realizingClassifier <- s.realizingClassifier
		)
}

rule Enumeration {
	from
		s: UML2!"uml::Enumeration" (
			thisModule.inElements -> includes(s)
		)
	to
		t: UML2!"uml::Enumeration" mapsTo s (
			name <- s.name,
			visibility <- s.visibility,
			isLeaf <- s.isLeaf,
			isAbstract <- s.isAbstract,
			eAnnotations <- s.eAnnotations,
			ownedComment <- s.ownedComment,
			clientDependency <- s.clientDependency,
			nameExpression <- s.nameExpression,
			elementImport <- s.elementImport,
			packageImport <- s.packageImport,
			ownedRule <- s.ownedRule,
			templateParameter <- s.templateParameter,
			templateBinding <- s.templateBinding,
			ownedTemplateSignature <- s.ownedTemplateSignature,
			generalization <- s.generalization,
			powertypeExtent <- s.powertypeExtent,
			redefinedClassifier <- s.redefinedClassifier,
			substitution <- s.substitution,
			representation <- s.representation,
			collaborationUse <- s.collaborationUse,
			ownedUseCase <- s.ownedUseCase,
			useCase <- s.useCase,
			ownedAttribute <- s.ownedAttribute,
			ownedOperation <- s.ownedOperation,
			ownedLiteral <- s.ownedLiteral
		)
}

-- ======================================================================
-- UML2 copying rules end
-- ======================================================================
