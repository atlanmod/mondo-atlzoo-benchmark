-- @nsURI UML=http://www.eclipse.org/uml2/3.0.0/UML
-- @path ITM=/org.eclipse.m2m.atl.tests/data/inputs/IteratorsTests/IteratorsTestsModel.ecore


module IteratorsTests;
create OUT: ITM from IN: UML;

helper def: sequenceTest: Sequence(TupleType(a: Integer, b: String)) =
	Sequence{Tuple{a: Integer = 8, b: String = 'eight'},
			Tuple{a: Integer = -1, b: String = 'minus one'},
			Tuple{a: Integer = 2, b: String = 'two 1'},
			Tuple{a: Integer = 2, b: String = 'two 2'},
			Tuple{a: Integer = -3, b: String = 'minus three'}};

rule IteratorsTests {
	from
		input: UML!Model
	to
		iterateTest: ITM!IterateTestClass (
			resultSum <- thisModule.sequenceTest -> iterate(i; var: Integer = 0 | var + i.
					a),
			-- This first iteration sum all the integer values of the tuples of the
					-- sequence
			result <- thisModule.sequenceTest -> iterate(i; var: String = '' | if i.a > 0
					then
						var + i.b + ' is positive - '
					else
						var + i.b + ' is negative - '
					endif) -- This second iteration says whether the integer value is
							-- positive or negative for each tuple
			
		),
		existsTest: ITM!ExistsTestClass (
			resultTrue <- thisModule.sequenceTest -> exists(i | i.a < 0),
			-- This one returns true if the sequence contains at least on tuple in
				-- which the 'a' parameter is negative (in our case, it does)
			resultFalse <- thisModule.sequenceTest -> exists(i | i.a > 15) -- This one
					-- returns true if the sequence contains at least on tuple in
				-- which the 'a' parameter is greater than 15 (in our case, it doesn't)
			
		),
		forAllTest: ITM!ForAllTestClass (
			resultFalse <- thisModule.sequenceTest -> forAll(i | i.a > 0),
			-- This one returns true if every tuple of the sequence has it 'a'
				-- parameter positive (in our case, it doesn't)
			resultTrue <- thisModule.sequenceTest -> forAll(i | i.a >= -3) -- This one
					-- returns true if every tuple of the sequence has its 'a'
				-- parameter greater or equal to 3 (in our case, it does)
			
		),
		isUniqueTest: ITM!IsUniqueTestClass (
			resultFalse <- thisModule.sequenceTest -> isUnique(i | i.a = 10),
			-- This one returns true if the results of each tuple's 'a' parameter
				-- compared to 10 are all different (that's just impossible -> false)
			resultTrue <- thisModule.sequenceTest -> isUnique(i | i.b) -- This one
					-- returns true if each tuple's 'b' parameter is unique
				-- (in our case, they are all differents)
			
		),
		anyTest: ITM!AnyTestClass (
			resultNull <- thisModule.sequenceTest -> any(i | i.a = -5) -> toString(),
			-- This one returns one tuple for which the 'a' parameter equals -5
				-- (in our case, none)
			resultNotNull <- thisModule.sequenceTest -> any(i | i.a > 1) -> toString() --
					-- This one returns one tuple for which the 'a' parameter is greater
					-- than 1
				-- (in our case, there are three possibilities : 8 (eight), 2 (two 1) and
						-- 2 (two 2))
			
		),
		oneTest: ITM!OneTestClass (
			resultTrue <- thisModule.sequenceTest -> one(i | i.a = 8),
			-- This one returns true if there is one and only one tuple for which it's
					-- 'a' parameter
				-- equals 8 (in our case, there is one indeed)
			resultFalse <- thisModule.sequenceTest -> one(i | i.a = 2) -- This one
					-- returns true if there is one and only one tuple for which it's 'a'
					-- parameter
				-- equals 2 (in our case, there is two, so it returns false)
			
		),
		collectTest: ITM!CollectTestClass (
			resultFalse <- thisModule.sequenceTest -> collect(i | i.a = 3) ->
					includes(true),
			-- This one returns true if the collect operation finds a tuple for which the
					-- 'a' parameter
				-- equals 3 (that is to say if the collect operation contains a true
						-- result, in our case, it doesn't)
			resultTrue <- thisModule.sequenceTest -> collect(i | i.a = 2) ->
					includes(true) -- This one returns true if the collect operation
					-- finds a tuple for which the 'a' parameter
				-- equals 2 (in our case, it does)
			
		),
		selectTest: ITM!SelectTestClass (
			resultNull <- thisModule.sequenceTest -> select(i | i.a = 3) -> flatten() ->
					toString(),
			-- This one returns a sequence containing the tuples for which the 'a'
					-- parameter equals 3
				-- (in our case, there is not, so it returns a empty sequence)
			resultNotNull <- thisModule.sequenceTest -> select(i | i.a = 2) -> flatten()
					-> toString() -- This one returns a sequence containing the tuples
					-- for which the 'a' parameter equals 2
				-- (in our case, there are two)
			
		),
		rejectTest: ITM!RejectTestClass (
			resultNull <- thisModule.sequenceTest -> reject(i | i.a > -4) -> flatten() ->
					toString(),
			-- This one returns a sequence containing the tuples for which the 'a'
					-- parameter IS NOT
				-- greater than -4 (in our case, there is not, so it returns a empty
						-- sequence)
			resultNotNull <- thisModule.sequenceTest -> reject(i | i.a = 3) -> flatten()
					-> toString() -- This one returns a sequence containing the tuples
					-- for which the 'a' parameter DOES NOT
				-- equal 3 (in our case, every tuple matches this condition)
			
		),
		sortedByTest: ITM!SortedByTestClass (
			resultByString <- thisModule.sequenceTest -> sortedBy(i | i.b) -> flatten()
					-> toString(),
			-- This one returns the test sequence sorted by the 'b' parameter of the
					-- tuples
			resultByInt <- thisModule.sequenceTest -> sortedBy(i | i.a) -> flatten() ->
					toString() -- This one returns the test sequence sorted by the 'a'
					-- parameter of the tuples
			
		)
}
